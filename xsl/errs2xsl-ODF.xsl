<!--this script produces XSLT to embed comments in the original instance
		
		A comment in WordML is effected by AML (Annotation Markup Language).
		
		Points to note:
		
		o An aml:annotation/@w:type='Word.Comment.Start' should be placed at 
			the start of a commented paragraph, an aml:annotation/@w:type='Word.Comment.End'
			after its last run child (w:r). 
			N.B. For an *inline* comment, only the run in question is wrapped.
		
		o	Multiple comments may reference the same region.
		
		o Comments must have a unique ID. This is provided by the $pos variable, since
			the IDs must also be in numerical order. 
		
		o The template named 'insert-comment' below shows the format comments should take.
			The ID of the comment start/end should match the ID of the 
			aml:annotation/@type='Word.Comment'. (The @aml:createDate is a nicety and may be
			omitted - Word will provide a default value at render-time.-->
			
<xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:out='http://www.w3.org/1999/XSL/TransformAlias'
  xmlns:svrl="http://purl.oclc.org/dsdl/svrl"
  xmlns:office='urn:oasis:names:tc:opendocument:xmlns:office:1.0'
  xmlns:dc='http://purl.org/dc/elements/1.1/'
  xmlns:text='urn:oasis:names:tc:opendocument:xmlns:text:1.0'>

<xsl:namespace-alias
  result-prefix="xsl"
  stylesheet-prefix="out" />
  
<xsl:output method="xml" indent='yes'/>
	
<xsl:template match="/">

<xsl:comment>auto-generated by errs2xsl.xsl</xsl:comment>

<!--the auto-generated stylesheet-->
<out:stylesheet version='2.0'
	xmlns:office='urn:oasis:names:tc:opendocument:xmlns:office:1.0'
	xmlns:dc='http://purl.org/dc/elements/1.1/'
	xmlns:text='urn:oasis:names:tc:opendocument:xmlns:text:1.0'
	exclude-result-prefixes='svrl'>

	<out:output indent='yes'/>

	<!--timestamp param for use in Word comments-->  
	<out:param name="timestamp" select="current-dateTime()" />
	<out:param name="debug" select="false()" />
	
	<xsl:variable name="errors" select="(//svrl:failed-assert|//svrl:successful-report)"/>

	<!--index all xpath locators-->
	<xsl:text>&#xA;</xsl:text>
	<xsl:comment>the following keys identify nodes in the original which are to be marked with comments</xsl:comment>
	<xsl:text>&#xA;</xsl:text>
	<xsl:comment>each key name is the ID of the error node in the QA report</xsl:comment>
	<xsl:for-each select="$errors">
		<out:key name='{generate-id()}' use='generate-id()'>
			<xsl:attribute name="match">
				<xsl:apply-templates select="@location"/>
			</xsl:attribute>
		</out:key>
	</xsl:for-each>
	<xsl:text>&#xA;</xsl:text>

	<out:template match="/">
		<out:comment>auto-generated by wordqa</out:comment>
		<out:apply-templates/>
	</out:template>
	
	<out:template match='*'>
		<out:copy>
			<out:apply-templates select='@*'/>
			<out:apply-templates/>
		</out:copy>	
	</out:template>
	
	<out:template match='@*'>
		<out:copy/>
	</out:template>
	
	<out:template match='//text()'>
		<out:copy/>
	</out:template>	
				
	<!--paras-->
	<out:template match="text:p | text:h">
		<xsl:variable name="p" select="."/>
		
		<out:variable name="id" select="generate-id(.)"/>
		<out:variable name="pos"
			select="count( preceding::* ) + count( ancestor-or-self::* )"/>
		
		<out:copy>
			<out:copy-of select="@*"/>

			<!-- 1. begin annotation -->
			<xsl:for-each select="$errors">
				<xsl:variable name="error-msg"
					select="translate(./svrl:text, &quot;'&quot;, '&quot;')"/>

				<!--now the actual comment content-->
				<out:for-each select="key( '{generate-id()}', $id )">
					<xsl:copy-of select="$p/@*"/>
					<out:call-template name="insert-comment">
						<out:with-param name="id">
							<xsl:attribute name="select"
								select="concat(&quot;'&quot;, generate-id(), &quot;'&quot;)"
							/>
						</out:with-param>
						<out:with-param name="message">
							<xsl:attribute name="select">'<xsl:value-of
									select="concat(@id,' ',$error-msg)"/>'</xsl:attribute>
						</out:with-param>
					</out:call-template>
				</out:for-each>

			</xsl:for-each>
			
			<!-- 2. original content -->
			<out:apply-templates/>
			
			<!-- 3. end annotation -->
			<xsl:for-each select="$errors">
				<!--comment end marker(s)-->
				<out:for-each select="key( '{generate-id()}', $id )">
					<office:annotation-end office:name="__Annotation__{generate-id()}"/>
				</out:for-each>
			</xsl:for-each>
			
		</out:copy>
		
	</out:template>
	
	<!--Word runs (=inline styles/formatting)-->
	<out:template match="text:span">
		<xsl:variable name="span" select="."/>

		<out:variable name="id" select="generate-id(.)"/>
		<out:variable name="pos"
			select="count( preceding::* ) + count( ancestor-or-self::* )"/>

		<!-- 1. begin annotation, wrapped in same style as text:span affected -->
		<xsl:for-each select="$errors">
			<xsl:variable name="error-msg"
				select="translate(./svrl:text, &quot;'&quot;, '&quot;')"/>

			<!--now the actual comment content-->
			<out:for-each select="key( '{generate-id()}', $id )">
				<text:span>
					<xsl:copy-of select="$span/@*"/>
					<out:call-template name="insert-comment">
						<out:with-param name="id">
							<xsl:attribute name="select"
								select="concat(&quot;'&quot;, generate-id(), &quot;'&quot;)"
							/>
						</out:with-param>
						<out:with-param name="message">
							<xsl:attribute name="select">'<xsl:value-of
									select="concat(@id,' ',$error-msg)"/>'</xsl:attribute>
						</out:with-param>
					</out:call-template>
				</text:span>
			</out:for-each>

		</xsl:for-each>


		<!-- 2. the original text:span -->
		<out:copy>
			<out:copy-of select="@*"/>
			<out:apply-templates/>
		</out:copy>

		<!-- 3. end annotation -->
		<xsl:for-each select="$errors">
			<!--comment end marker(s)-->
			<out:for-each select="key( '{generate-id()}', $id )">
				<office:annotation-end office:name="__Annotation__{generate-id()}"/>
			</out:for-each>
		</xsl:for-each>

	</out:template>	
	
	<out:template name='insert-comment'>
		<out:param name='id'/>
		<out:param name='message'/>
		
		<office:annotation>
			<xsl:attribute name="office:name">__Annotation__{$id}</xsl:attribute>
			<dc:creator>QA</dc:creator>
			<dc:date><xsl:value-of select="current-dateTime()"/></dc:date>
			<text:list text:style-name="">
				<text:list-item>
					<text:p text:style-name="P3">
						<text:span text:style-name="T6">
							<xsl:element name='value-of' namespace='http://www.w3.org/1999/XSL/Transform'>
								<xsl:attribute name="select">$message</xsl:attribute>
							</xsl:element>
						</text:span>
					</text:p>
				</text:list-item>
			</text:list>
		</office:annotation>
	</out:template>
	
	<!--Word PIs-->
	<out:template match='processing-instruction("mso-application")'>
		<out:copy-of select='.'/>
	</out:template>
	
	</out:stylesheet>	
	
</xsl:template>	
	
	<!-- the Steps in XPaths we use to generate key matches need to be QNames,
	whereas those reported by the ISO Schematron XSLT implementation are in the form
	*:p[namespace-uri()='...']. 
	This template removes the namespace predicate and inserts the correct prefix. -->
	<xsl:template match="svrl:failed-assert/@location | svrl:successful-report/@location">
		<xsl:for-each select="tokenize(., '/\*:')[position() > 1]">	<!-- split by '/*:' -->
			<xsl:text>/</xsl:text>
			<xsl:variable name="tokens" select="tokenize(., '\[')"/>
			<xsl:variable name="ns-uri" select="substring-before( substring-after($tokens[2], &quot;namespace-uri()='&quot;), &quot;'&quot;)"/>
			<xsl:choose>
				<xsl:when test="$ns-uri = 'urn:oasis:names:tc:opendocument:xmlns:text:1.0'">text:</xsl:when>
				<xsl:when test="$ns-uri = 'urn:oasis:names:tc:opendocument:xmlns:office:1.0'">office:</xsl:when>
				<xsl:when test="$ns-uri = 'urn:oasis:names:tc:opendocument:xmlns:style:1.0'">style:</xsl:when>
				<!-- N.B. others may be required! -->
				<xsl:otherwise><xsl:message>unrecognised namespace: <xsl:value-of select="$ns-uri"/></xsl:message></xsl:otherwise>
			</xsl:choose>
			<xsl:value-of select="$tokens[1]"/>[<xsl:value-of select="$tokens[3]"/>	
		</xsl:for-each>
	</xsl:template>
	
</xsl:stylesheet>